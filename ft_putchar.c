/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print_alphabet.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: zanyda <darrnokturna@42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/12/30 23:43:18 by zanyda            #+#    #+#             */
/*   Updated: 2019/12/30 23:43:18 by zanyda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>		// Эта библиотека требуется для вывода символов, см man write http://ru.manpages.org/write/2

/*
** 1. Используем тут void, т.к. функцию ft_putchar не надо возвращать никаких значений.
** Тут она обозначена пустой т.к. мы ее будем постоянно использовать.
**
** 2. Функция (ft_putchar) лишь преобразует переменную (с) с типом данных (char) [см. таблицу ASCII]
** выполняя указанные параметры {выводить на экран, нигде не сохраняя}. Преобразование происходит
** через передачу переменной (c) в блок кода и возвращает ее обратно выполнив указанные действия.
**
** 3. Допустим, если мы поставим на место (с) – (97), то мы получим символ (a) [см. таблицу ASCII],
** с определенными параметрами write.
*/
void ft_putchar(char c)	// Создаем функцию
{						// тело функции
	write(1, &c, 1);	// тело функции
}						// тело функции
/*
** Изменяем полученную переменную (с) с функцией (write) с определенными параметрами и возвращаем ее значение.
** (&c – ссылка на переменную, c – сокр. char).
**
** Функция write имеет следующие параметры (<дескриптор.потока>, <&указатель на буфер>, <число.записыв.байтов>):
**
** 1. int <дескриптор(идентификатор) потока ввода/вывода>:
** 0	stdin	– стандартное устройство ввода (клавиатура);
** 1	stdout	– стандартное устройство вывода (экран);
** 2	stderr	– стандартное устройство вывода сообщения об ошибках (также экран).
** Простыми словами при открытии файла операционная система создает запись для представления этого файла
** и сохраняет информацию об этом открывшемся файле. Итак, если в вашей ОС открыто 100 файлов, то в ОС
** будет находиться 100 записей (где-то в ядре). Эти записи представлены целыми числами типа (... 100, 101, 102....).
** Этот номер записи является файловым дескриптором. Таким образом, это просто целое число, которое уникально
** представляет собой открытый файл в операционной системе. Если ваш процесс откроет 10 файлов, ваша таблица процессов
** будет содержать 10 записей для дескрипторов файлов.
** Еще простыми словами: чтобы попасть в город (прочитать/записать в файл) мы едем через мост (дескриптор).
**
** 2. const void *buf <указатель на буфер> - адрес, куда мы будем записывать наши данные (байты) и возращать их.
** Значение из ft_putchar(char c(отсюда)) передав его в write(1, &c(cюда), 1).
** Синтаксис, когда мы делаем ссылку на адрес с → &c.
**
** 3. size_t count <число записываемых байтов> - количество пересылаемых данных (1 byte - 1 char).
** Эта функция записывает один символ в стандартный поток вывода терминала.
**
** На выходе имеем функцию write – с параметрами вывода паременной (с) на экран по 1 символу.
** Это одна из самых основных и необходимых функций в нашей библиотеке.
*/